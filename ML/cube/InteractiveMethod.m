classdef InteractiveMethod < dynamicprops    
    %{ 
    Cube plugin class for interactive methods
    
    Description:
    ============
        - Base class for interactive methods
            * Method handle
            * Cell array of parameters, used to call the method
                * Parameters can be changed through a GUI (build with CubeInteractiveMethod.build_gui) or CLI prompt
    %}
    
    properties
       methodh = false;         % Method handle
       current = {};            % Current parameter values   % Reflect changes to parameters (e.g. ~ orthofig) in CubePostprocess instances!
       default = {};            % Default parameter values
       minimum = {};            % Minimum parameter values
       maximum = {};            % Maximum parameter values
    end
    
    properties(Hidden = true)
        method = '';            % Method name
        parname = {};           % Used in GUI and CLI to identify parameters. If CubeInteractiveMethod.methodh is an
                                % anonymous function, the parname array can be autogenerated from that.
                                % To save space, use uicontrol.TooltipString maybe! https://nl.mathworks.com/matlabcentral/answers/81373-how-to-add-mouseover-in-gui
        options = {};           % Additional options (required? not sure...)
        numeric = [];
        callback = false;
        expects = @single;      % Expected input data type
        
        gui_handles = {};     % 
        gui_height = 20;
        gui_max_width = 160;
        gui_gap = 2;
    end
    
    methods(Access = public)
        function self = InteractiveMethod(methodh, default, minimum, maximum, options, expects)
            switch nargin
                case 2
                    minimum = {};
                    maximum = {};
                    options = {};
                    expects = @single;
                case 3
                    maximum = {};
                    options = {};
                    expects = @single;
                case 4
                    options = {};
                    expects = @single;
                case 5
                    expects = @single;
            end
            
            self.methodh = methodh;         % Should perform checks!
            self.default = default;
            self.current = self.default;
            self.minimum = minimum;
            self.maximum = maximum;
            self.options = options;
            self.expects = expects;
            
            self.setup;
        end
        
        function set_callback(self, callback)
           self.callback = callback; % todo: basic sanity checks 
        end
        
        function out = do(self, in)
            % Call method with current parameter values
            out = self.methodh(self.expects(in), self.current{:});
        end
        
        function update_numeric_parameter(self, source, event)
            i = self.get_parameter_index(source); % Parameter index (see InteractiveMethod.build_gui)         
            new_value = str2num(source.String);
            self.current{i} = min(max(new_value, self.minimum{i}), self.maximum{i}); % todo: do this same sanity check when setting default value in constructor!
            source.String = self.current{i};
            
            if isa(self.callback, 'function_handle')
                self.callback();
            end
        end
        
        function update_string_parameter(self, source, event)
            i = self.get_parameter_index(source); % Parameter index (see InteractiveMethod.build_gui)
            self.current{i} = source.String;
            if isa(self.callback, 'function_handle')
                self.callback();
            end
        end
        
        function gui_handles = build_gui(self, figure, anchor)
            % Build own GUI at anchor in figure
            % ALSO: implement callbacks ~ this gui
            
            % TODO: handle string and numeric values, uicontrol('edit') vs uieditfield
            
            gui_handles = cell(size(self.parname));      
            parN = length(self.parname);
            gui_width = floor(self.gui_max_width / parN);
            
            for i = 1:parN                
                if self.numeric(i)
                    callback = @self.update_numeric_parameter;
                else
                    callback = @self.update_string_parameter;
                end
                
                gui_handles{i} = uicontrol( ...
                    'Parent', figure, 'Style', 'edit', 'TooltipString', self.parname{i}, ...
                    'String', num2str(self.current{i}), 'Callback', callback, ...
                    'Position', [anchor(1)+(i-1)*(gui_width+self.gui_gap), anchor(2), gui_width, self.gui_height] ...
                );
            
                self.set_parameter_index(gui_handles{i}, i);
            end
        end
        
        function cli(self)
            % Prompt own parameters in the MATLAB commandline
            %   User enters string, also show default values
            %       - If empty string (i.e. just pressed enter) -> use default values
            %       - If format ~ 156 156 stuff 156 -> self.current = {156, 156, 'stuff', 156}; assume order; to skip a value, use ~
            %       - If 'help' -> show some help
            %       - If par1 156 par7 156 -> query index by parname, prompt again if specified parname not found
            %       (Would be nice: - Also parse arrays ~ MATLAB syntax, i.e. ignore spaces within brackets)
        end
    end
    
    methods(Static)
        function set_parameter_index(handle, i)
            % Set parameter index in associated uicontrol
            set(handle, 'UserData', i);
        end
        
        function i = get_parameter_index(handle)
            % Get parameter index from associated uicontrol
            i = get(handle, 'UserData');
        end
    end
    
    methods(Access = protected)
        function setup(self)
            if ~isempty(self.methodh)
               fs = functions(self.methodh);
               
               switch fs.type
                   case 'anonymous'
                       [tokens] = regexp(fs.function, '@\(([a-zA-Z0-9,~_]+)\)(.*)', 'tokens');        
                        % To get 'pars': extract contents of brackets "@(...)" into a cell array of strings <- second token
                        self.parname = split(tokens{1}{1}, ',');
                        self.parname = self.parname(2:end); % First parameter doesn't need an interface (it's the slice or cube)
                        % To get 'func': remove "@(...) " from fs.func <- first token
                        self.method = tokens{1}{2};    
                        
                        % TODO: string parameter min/max should just be ''
                        
                        if isempty(self.minimum)
                           self.minimum = num2cell(-Inf * ones(size(self.default)));
                        end
                        
                        if isempty(self.maximum)
                           self.maximum = num2cell(Inf * ones(size(self.default)));
                        end
                        
                        for i = 1:length(self.default)
                            self.numeric(i) = isnumeric(self.default{i});
                        end
                        
                        
                   case 'simple'
                        error('Please wrap regular functions in an anonymous function so parameter names can be retained!')
                   otherwise
                       error('What even is this function: %s', fs.function) 
               end
            else
                error('Function handle is empty also make this error more informative pls')
            end
        end
        

    end
end