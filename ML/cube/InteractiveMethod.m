classdef InteractiveMethod < dynamicprops    
    %{ 
    Cube plugin class for interactive methods
    
    Description:
    ============
        - Base class for interactive methods
            * Method handle
            * Cell array of parameters, used to call the method
                * Parameters can be changed through a GUI (build with CubeInteractiveMethod.build_gui) or CLI prompt
    %}
    
    properties
       methodh = false;         % Method handle
       current = {};            % Current parameter values   % Reflect changes to parameters (e.g. ~ orthofig) in CubePostprocess instances!
       default = {};            % Default parameter values
       minimum = {};            % Minimum parameter values
       maximum = {};            % Maximum parameter values
    end
    
    properties(Hidden = true)
        method = '';            % Method name
        parname = {};           % Used in GUI and CLI to identify parameters. If CubeInteractiveMethod.methodh is an
                                % anonymous function, the parname array can be autogenerated from that.
                                % To save space, use uicontrol.TooltipString maybe! https://nl.mathworks.com/matlabcentral/answers/81373-how-to-add-mouseover-in-gui
        options = {};           % Additional options (required? not sure...)
        numeric = [];
        callback = false;
        expects = @single;      % Expected input data type
        
        gui_handles = {};       % 
    end
    
    methods(Access = public)
        function self = InteractiveMethod(methodh, parname, default, minimum, maximum, options, expects)
            switch nargin
                case 3
                    minimum = {};
                    maximum = {};
                    options = {};
                    expects = @single;
                case 4
                    maximum = {};
                    options = {};
                    expects = @single;
                case 5
                    options = {};
                    expects = @single;
                case 6
                    expects = @single;
            end
            
            self.methodh = methodh;         % Should perform checks!
            self.parname = parname;
            self.default = default;
            self.current = self.default;
            self.minimum = minimum;
            self.maximum = maximum;
            self.options = options;
            self.expects = expects;
            
            self.setup;
        end
        
        function set_callback(self, callback)
           self.callback = callback; % todo: basic sanity checks 
        end
        
        function out = do(self, in, varargin) % TODO: should handle nargin after 'in' by modifying self.current -> i.e. call slice.do(cube, 123) -> 123 to first parameter in self.current
            % Call method with current parameter values     
            for i = 1:numel(varargin)
               self.current{i} = varargin{i}; 
            end
            
            out = self.methodh(self.expects(in), self.current{:});
        end
        
        function set(self, parameter, value)
            if any(strcmp(parameter, self.parname))
                i = find(not(cellfun('isempty', strfind(self.parname, parameter)))); % https://nl.mathworks.com/matlabcentral/answers/2015-find-index-of-cells-containing-my-string
%                 if class(value) == class(self.default{i})     % todo: with check: too stringent
                self.current{i} = value;    % todo: without check: too loose
%                 end
            end
        end
        
        function update_numeric_parameter(self, source, ~)
            i = self.get_parameter_index(source); % Parameter index (see InteractiveMethod.build_gui)         
            new_value = str2num(source.String);
            self.current{i} = min(max(new_value, self.minimum{i}), self.maximum{i}); % todo: do this same sanity check when setting default value in constructor!
            source.String = self.current{i};
            
            if isa(self.callback, 'function_handle')
                self.callback();
            end
        end
        
        function update_string_parameter(self, source, ~)
            i = self.get_parameter_index(source); % Parameter index (see InteractiveMethod.build_gui)
            self.current{i} = source.String;
            if isa(self.callback, 'function_handle')
                self.callback();
            end
        end
        
        function gui_handles = build_gui(self, figure, anchor, callback, disabled_parameters)
            % Build own GUI at anchor in figure
            % ALSO: implement callbacks ~ this gui
            
            % TODO: handle string and numeric values, uicontrol('edit') vs uieditfield
            
            switch nargin
                case 4
                    disabled_parameters = {};               
            end
            
            self.set_callback(callback);
            

            % Remove disabled parameters from self.parname
            % https://nl.mathworks.com/matlabcentral/answers/298884-remove-cell-that-contains-strings-of-another-cell-array
            
            x = false(size(self.parname));
            for k=1:numel(disabled_parameters)
                x = x | strcmp(self.parname,disabled_parameters{k});
            end
            enabled_parameters = self.parname;
            enabled_parameters(x) = [];
            
            gui = interactive_methods_gui;
            
            gui_handles = cell(size(enabled_parameters));      
            parN = length(enabled_parameters);
            gui_width = floor(gui.controls_max_width / parN);
            
            k = 1;
            for i = 1:length(self.parname)  
                if any(strcmp(self.parname{i}, enabled_parameters))
                    if self.numeric(i)
                        parameter_callback = @self.update_numeric_parameter;
                    else
                        parameter_callback = @self.update_string_parameter;
                    end

                    gui_handles{i} = uicontrol( ...
                        'Parent', figure, 'Style', 'edit', 'TooltipString', self.parname{i}, ...
                        'FontSize', gui.fontsize, 'String', num2str(self.current{i}), ...
                        'Callback', parameter_callback, ...
                        'Position', [anchor(1)+(k-1)*(gui_width+gui.gap), anchor(2), gui_width, gui.height] ...
                    );
                    k = k+1;

                    self.set_parameter_index(gui_handles{i}, i);
%                     self.callback(); % todo: temporary, this is not a good idea if values for (source, event) are used!
                end
            end
        end
        
        function cli(~)
            % Prompt own parameters in the MATLAB commandline
            %   User enters string, also show default values
            %       - If empty string (i.e. just pressed enter) -> use default values
            %       - If format ~ 156 156 stuff 156 -> self.current = {156, 156, 'stuff', 156}; assume order; to skip a value, use ~
            %       - If 'help' -> show some help
            %       - If par1 156 par7 156 -> query index by parname, prompt again if specified parname not found
            %       (Would be nice: - Also parse arrays ~ MATLAB syntax, i.e. ignore spaces within brackets)
        end
    end
    
    methods(Static)
        function set_parameter_index(handle, i)
            % Set parameter index in associated uicontrol
            set(handle, 'UserData', i);
        end
        
        function i = get_parameter_index(handle)
            % Get parameter index from associated uicontrol
            i = get(handle, 'UserData');
        end
    end
    
    methods(Access = protected)
        function setup(self)
            if ~isempty(self.methodh)
               fs = functions(self.methodh);
               
               switch fs.type
                   case 'anonymous'
                       [tokens] = regexp(fs.function, '@\(([a-zA-Z0-9,~_]+)\)(.*)', 'tokens');        
                       
                        if isempty(self.parname)
                            % To get 'pars': extract contents of brackets "@(...)" into a cell array of strings <- second token
                            self.parname = split(tokens{1}{1}, ',');
                            self.parname = self.parname(2:end); % First parameter doesn't need an interface (it's the slice or cube)
                            % To get 'func': remove "@(...) " from fs.func <- first token
                        end
                        self.method = tokens{1}{2};    
                        
                        % TODO: string parameter min/max should just be ''
                        
                        
                   case {'simple', 'scopedfunction', 'nested'}
                        self.method = fs.function;
                   otherwise
                       error('What even is a %s function: %s', fs.type, fs.function)
                end
               
                if isempty(self.minimum)
                   self.minimum = num2cell(-Inf * ones(size(self.default)));
                end

                if isempty(self.maximum)
                   self.maximum = num2cell(Inf * ones(size(self.default)));
                end

                for i = 1:length(self.default)
                    self.numeric(i) = isnumeric(self.default{i});
                end
            else
                error('Function handle is empty also make this error more informative pls')
            end
        end
        

    end
end